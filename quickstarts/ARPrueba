{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/letsplaydarck/ige_prototype/blob/master/quickstarts/ARPrueba\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "Tce3stUlHN0L"
      },
      "source": [
        "##### Copyright 2025 Google LLC."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 14,
      "metadata": {
        "id": "tuOe1ymfHZPu"
      },
      "outputs": [],
      "source": [
        "#@title Licensed under the Apache License, Version 2.0 (the \"License\");\n",
        "# you may not use this file except in compliance with the License.\n",
        "# You may obtain a copy of the License at\n",
        "#\n",
        "# https://www.apache.org/licenses/LICENSE-2.0\n",
        "#\n",
        "# Unless required by applicable law or agreed to in writing, software\n",
        "# distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "# See the License for the specific language governing permissions and\n",
        "# limitations under the License."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "Y_lgX9omPXF-"
      },
      "source": [
        "## Grounding using Search as a tool"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "VkR4fWudrHCs"
      },
      "source": [
        "<a target=\"_blank\" href=\"https://colab.research.google.com/github/google-gemini/cookbook/blob/main/quickstarts/Search_Grounding.ipynb\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" height=30/></a>"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "WDKKNfXWrHgs"
      },
      "source": [
        "In this notebook you will learn how to use the new Google Search tool available in the [Gemini](https://ai.google.dev/gemini-api/docs/models/gemini-v2) models, using both the unary API and the Multimodal Live API. Check out the docs to learn more about using [Search as a tool](https://ai.google.dev/gemini-api/docs/models/gemini-v2#search-tool).\n",
        "\n",
        "Note that the previous version of this guide using Gemini models priori to 2.0 and the legacy SDK can still be found [here](https://github.com/google-gemini/cookbook/blob/gemini-1.5-archive/quickstarts/Search_Grounding.ipynb)."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "vKu1tRBrQ7xj"
      },
      "source": [
        "## Set up the SDK and the client"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "vIWKUlPqP5NK"
      },
      "source": [
        "### Install SDK\n",
        "\n",
        "This guide uses the [`google-genai`](https://pypi.org/project/google-genai) Python SDK to connect to the Gemini models.\n",
        "\n",
        "You'll find more details about the SDK on the [documentation](https://googleapis.github.io/python-genai/) or in the [Getting started](./Get_started.ipynb) notebook."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 15,
      "metadata": {
        "id": "6Fr84vJuPSHb",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "48cb6bda-5567-4292-a06b-f444f75e0681"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "\u001b[2K     \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m53.3/53.3 kB\u001b[0m \u001b[31m2.6 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m426.6/426.6 kB\u001b[0m \u001b[31m18.7 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m233.3/233.3 kB\u001b[0m \u001b[31m15.6 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25h\u001b[31mERROR: pip's dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts.\n",
            "google-colab 1.0.0 requires google-auth==2.43.0, but you have google-auth 2.45.0 which is incompatible.\u001b[0m\u001b[31m\n",
            "\u001b[0m"
          ]
        }
      ],
      "source": [
        "%pip install -q -U \"google-genai>=1.0.0\""
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "a503bnWNQoCL"
      },
      "source": [
        "### Set up your API key\n",
        "\n",
        "To run the following cell, your API key must be stored it in a Colab Secret named `GOOGLE_API_KEY`. If you don't already have an API key, or you're not sure how to create a Colab Secret, see the [Authentication](https://github.com/google-gemini/gemini-api-cookbook/blob/main/quickstarts/Authentication.ipynb) quickstart for an example."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 16,
      "metadata": {
        "id": "RjvgYmdLQd5s",
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 311
        },
        "outputId": "f6285fc7-5ebc-4b3b-dd53-c352ddbf2b15"
      },
      "outputs": [
        {
          "output_type": "error",
          "ename": "SecretNotFoundError",
          "evalue": "Secret GOOGLE_API_KEY does not exist.",
          "traceback": [
            "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
            "\u001b[0;31mSecretNotFoundError\u001b[0m                       Traceback (most recent call last)",
            "\u001b[0;32m/tmp/ipython-input-1415439738.py\u001b[0m in \u001b[0;36m<cell line: 0>\u001b[0;34m()\u001b[0m\n\u001b[1;32m      2\u001b[0m \u001b[0;32mfrom\u001b[0m \u001b[0mgoogle\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcolab\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0muserdata\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      3\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 4\u001b[0;31m \u001b[0mos\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0menviron\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m'GOOGLE_API_KEY'\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0muserdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mget\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'GOOGLE_API_KEY'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
            "\u001b[0;32m/usr/local/lib/python3.12/dist-packages/google/colab/userdata.py\u001b[0m in \u001b[0;36mget\u001b[0;34m(key)\u001b[0m\n\u001b[1;32m     66\u001b[0m     \u001b[0;32mraise\u001b[0m \u001b[0mTimeoutException\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mkey\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     67\u001b[0m   \u001b[0;32mif\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0mresp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mget\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'exists'\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;32mFalse\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 68\u001b[0;31m     \u001b[0;32mraise\u001b[0m \u001b[0mSecretNotFoundError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mkey\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     69\u001b[0m   \u001b[0;32mif\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0mresp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mget\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'access'\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;32mFalse\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     70\u001b[0m     \u001b[0;32mraise\u001b[0m \u001b[0mNotebookAccessError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mkey\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;31mSecretNotFoundError\u001b[0m: Secret GOOGLE_API_KEY does not exist."
          ]
        }
      ],
      "source": [
        "import os\n",
        "from google.colab import userdata\n",
        "\n",
        "os.environ['GOOGLE_API_KEY'] = userdata.get('GOOGLE_API_KEY')"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "792cf95e"
      },
      "source": [
        "import os\n",
        "from google import genai\n",
        "\n",
        "api_key = os.environ.get('GOOGLE_API_KEY') # Retrieve the API key from the environment\n",
        "client = genai.Client(api_key=api_key) # Pass the API key explicitly\n",
        "\n",
        "MODEL_ID = \"gemini-3-flash-preview\" # @param [\"gemini-2.5-flash-lite\", \"gemini-2.5-flash\", \"gemini-2.5-pro\", \"gemini-2.5-flash-preview\", \"gemini-3-pro-preview\"] {\"allow-input\":true, isTemplate: true}"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "VhKXgMSNQrrV"
      },
      "source": [
        "### Select model and initialize SDK client\n",
        "\n",
        "The client will pick up your API key from the environment variable.\n",
        "\n",
        "Now select the model you want to use in this guide, either by selecting one in the list or writing it down. Keep in mind that some models, like the 2.5 ones are thinking models and thus take slightly more time to respond (cf. [thinking notebook](./Get_started_thinking.ipynb) for more details and in particular learn how to switch the thiking off)."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "C75s1LR9QmOz"
      },
      "outputs": [],
      "source": [
        "from google import genai\n",
        "\n",
        "client = genai.Client() # the API is automatically loaded from the environement variable\n",
        "\n",
        "MODEL_ID = \"gemini-3-flash-preview\" # @param [\"gemini-2.5-flash-lite\", \"gemini-2.5-flash\", \"gemini-2.5-pro\", \"gemini-2.5-flash-preview\", \"gemini-3-pro-preview\"] {\"allow-input\":true, isTemplate: true}"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "200791fb"
      },
      "source": [
        "import os\n",
        "from google import genai\n",
        "\n",
        "api_key = os.environ.get('GOOGLE_API_KEY') # Retrieve the API key from the environment\n",
        "client = genai.Client(api_key=api_key) # Pass the API key explicitly\n",
        "\n",
        "MODEL_ID = \"gemini-3-flash-preview\" # @param [\"gemini-2.5-flash-lite\", \"gemini-2.5-flash\", \"gemini-2.5-pro\", \"gemini-2.5-flash-preview\", \"gemini-3-pro-preview\"] {\"allow-input\":true, isTemplate: true}"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "8mDMScex1It5"
      },
      "source": [
        "## Use Google Search\n",
        "Search grounding is particularly useful for queries that require current information or external knowledge. Using Google Search, Gemini can access nearly real-time information and better responses."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "FHIcazUO0-xU"
      },
      "outputs": [],
      "source": [
        "from IPython.display import HTML, Markdown\n",
        "\n",
        "response = client.models.generate_content(\n",
        "    model=MODEL_ID,\n",
        "    contents='What was the latest Indian Premier League match and who won?',\n",
        "    config={\"tools\": [{\"google_search\": {}}]},\n",
        ")\n",
        "\n",
        "# print the response\n",
        "display(Markdown(f\"Response:\\n {response.text}\"))\n",
        "# print the search details\n",
        "print(f\"Search Query: {response.candidates[0].grounding_metadata.web_search_queries}\")\n",
        "# urls used for grounding\n",
        "print(f\"Search Pages: {', '.join([site.web.title for site in response.candidates[0].grounding_metadata.grounding_chunks])}\")\n",
        "\n",
        "display(HTML(response.candidates[0].grounding_metadata.search_entry_point.rendered_content))"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "wROLHEYLLBHX"
      },
      "source": [
        "The information provided may be outdated, as it is based on a knowledge cutoff. For the most current and authoritative details, please refer to the official [Model documentation](https://ai.google.dev/gemini-api/docs/models#gemini-2.5-pro), which includes the latest knowledge cutoff date.\n",
        "\n",
        "You can see that running the same prompt without search grounding gives you outdated information:"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "EdUkQ40cKaGX"
      },
      "outputs": [],
      "source": [
        "from IPython.display import Markdown\n",
        "\n",
        "response = client.models.generate_content(\n",
        "    model=MODEL_ID,\n",
        "    contents='What was the latest Indian Premier League match and who won?',\n",
        ")\n",
        "\n",
        "# print the response\n",
        "display(Markdown(response.text))"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "lYGib8EySfBE"
      },
      "source": [
        "## Use search in chat\n",
        "\n",
        "Start by defining a helper function that you will use to display each part of the returned response."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "LUTX1SsKS3CE"
      },
      "outputs": [],
      "source": [
        "# @title Define some helpers (run this cell)\n",
        "import json\n",
        "\n",
        "from IPython.display import display, HTML, Markdown\n",
        "\n",
        "\n",
        "def show_json(obj):\n",
        "  print(json.dumps(obj.model_dump(exclude_none=True), indent=2))\n",
        "\n",
        "def show_parts(r):\n",
        "  parts = r.candidates[0].content.parts\n",
        "  if parts is None:\n",
        "    finish_reason = r.candidates[0].finish_reason\n",
        "    print(f'{finish_reason=}')\n",
        "    return\n",
        "  for part in r.candidates[0].content.parts:\n",
        "    if part.text:\n",
        "      display(Markdown(part.text))\n",
        "    elif part.executable_code:\n",
        "      display(Markdown(f'```python\\n{part.executable_code.code}\\n```'))\n",
        "    else:\n",
        "      show_json(part)\n",
        "\n",
        "  grounding_metadata = r.candidates[0].grounding_metadata\n",
        "  if grounding_metadata and grounding_metadata.search_entry_point:\n",
        "    display(HTML(grounding_metadata.search_entry_point.rendered_content))\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "YVlvJLcUTSuU"
      },
      "source": [
        "First try a query that needs realtime information, so you can see how the model performs _without_ Google Search."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "Qilzz3GKTdpl"
      },
      "outputs": [],
      "source": [
        "chat = client.chats.create(model=MODEL_ID)\n",
        "\n",
        "response = chat.send_message('Who won the most recent Australia vs Chinese Taipei games?')\n",
        "\n",
        "show_parts(response)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "svT-7wNdTCCj"
      },
      "source": [
        "Now set up a new chat session that uses the `google_search` tool.  The `show_parts` helper will display the text output as well as any Google Search queries used in the results."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "St4MxVo2Sl6I"
      },
      "outputs": [],
      "source": [
        "search_tool = {'google_search': {}}\n",
        "\n",
        "soccer_chat = client.chats.create(\n",
        "    model=MODEL_ID,\n",
        "    config={'tools': [search_tool]}\n",
        ")\n",
        "\n",
        "response = soccer_chat.send_message('Who won the most recent Australia vs Chinese Taipei games?')\n",
        "\n",
        "show_parts(response)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "BfkT7th0Tu1w"
      },
      "source": [
        "As you are using a `chat` session, you can ask the model follow-up questions too."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "4L40g89mTyPs"
      },
      "outputs": [],
      "source": [
        "response = soccer_chat.send_message('Who scored the goals?')\n",
        "\n",
        "show_parts(response)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "5liw_rs4T-gc"
      },
      "source": [
        "## Plot search results\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "_VOKNOHLULMI"
      },
      "source": [
        "In this example you can see how to use the Google Search tool with code generation in order to plot results."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "n00CHfm0UKp1"
      },
      "outputs": [],
      "source": [
        "movie_chat = client.chats.create(\n",
        "    model=MODEL_ID,\n",
        "    config={'tools': [search_tool]}\n",
        ")\n",
        "\n",
        "response = movie_chat.send_message('Generate some Python code to plot the runtimes of the 10 more recent Denis Villeneuve movies.')\n",
        "\n",
        "show_parts(response)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "6JTk_5hnVw0r"
      },
      "source": [
        "First review the supplied code to make sure it does what you expect, then copy it here to try out the chart."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "42UTFDweVwNm"
      },
      "outputs": [],
      "source": [
        "import re\n",
        "\n",
        "matchFound = re.search(r\"python\\n(.*?)```\", response.text, re.DOTALL)\n",
        "print(matchFound.group(1))\n",
        "if matchFound:\n",
        "  code = matchFound.group(1)\n",
        "  exec(code)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "jaMG2MmuWId3"
      },
      "source": [
        "One feature of using a chat conversation to do this is that you can now ask the model to make changes."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "K0vk3ol5WMvN"
      },
      "outputs": [],
      "source": [
        "response = movie_chat.send_message('Looks great! Can you give the chart a dark theme instead?')\n",
        "\n",
        "show_parts(response)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "16B0usiYaTBH"
      },
      "source": [
        "Again, always be sure to review code generated by the model before running it."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "vtfTv4ieFjYt"
      },
      "outputs": [],
      "source": [
        "import re\n",
        "\n",
        "matchFound = re.search(r\"python\\n(.*?)```\", response.text, re.DOTALL)\n",
        "\n",
        "if matchFound:\n",
        "  code = matchFound.group(1)\n",
        "  exec(code)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "SUwwmbbRawwZ"
      },
      "source": [
        "## Use search in the Multimodal Live API\n",
        "\n",
        "The Search tool can be used in a live streaming context to have the model formulate grounded responses during the conversation."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "CUhcThmnK0mt"
      },
      "outputs": [],
      "source": [
        "LIVE_MODEL_ID = 'gemini-2.5-flash-native-audio-preview-09-2025'  # @param ['gemini-2.0-flash-live-001', 'gemini-live-2.5-flash-preview', 'gemini-2.5-flash-native-audio-preview-09-2025'] {allow-input: true, isTemplate: true}"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "bax_JvhPdIry"
      },
      "source": [
        "### Define some helpers\n",
        "\n",
        "To use the bi-directional streaming API in Colab, you will buffer the audio stream. Define a `play_response` helper function to do the buffering, and once the audio for the current turn has completed, display an IPython audio widget.\n",
        "\n",
        "As each of the following examples only use a single prompt, also define a `run` helper to wrap the setup and prompt execution steps into a single function call. This helper takes a `config` argument that will be added to the `generation_config`, so that you can toggle the Search tool between examples."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "cellView": "form",
        "id": "YEAdoUV2dH1o"
      },
      "outputs": [],
      "source": [
        "# @title Helper functions for the Live API (run this cell)\n",
        "\n",
        "import asyncio\n",
        "import io\n",
        "import json\n",
        "import re\n",
        "import time\n",
        "import wave\n",
        "\n",
        "import numpy as np\n",
        "from IPython.display import Audio, display\n",
        "\n",
        "\n",
        "DEFAULT_OUTPUT_RATE = 24000\n",
        "BASE_MODEL_CONFIG = {\n",
        "    # Here you can change the model's output mode between either audio or text.\n",
        "    # While this code expects an audio stream, text should work, but the stream\n",
        "    # may interleave with the `Buffering....` text.\n",
        "    'response_modalities': ['AUDIO']\n",
        "}\n",
        "\n",
        "async def play_response(stream):\n",
        "  \"\"\"Buffer audio output and display a widget. Returns the streamed responses.\"\"\"\n",
        "  turn_buf = io.BytesIO()\n",
        "  sample_rate = DEFAULT_OUTPUT_RATE\n",
        "\n",
        "  all_responses = []\n",
        "\n",
        "  print('Buffering', end='')\n",
        "  async for msg in stream.receive():\n",
        "    all_responses.append(msg)\n",
        "\n",
        "    if audio_data := msg.data:  # This is what triggers the warnings, use the full path to access the audio data\n",
        "      turn_buf.write(audio_data)\n",
        "      if m := re.search(\n",
        "          'rate=(?P<rate>\\d+)',\n",
        "          msg.server_content.model_turn.parts[0].inline_data.mime_type\n",
        "      ):\n",
        "            sample_rate = int(m.group('rate'))\n",
        "\n",
        "    elif tool_call := msg.tool_call:\n",
        "      # Handle tool-call requests. Here is where you would implement\n",
        "      # custom tool code, but for this example, all tools respond 'ok'.\n",
        "      for fc in tool_call.function_calls:\n",
        "        print('Tool call', end='')\n",
        "        tool_response = genai.types.LiveClientToolResponse(\n",
        "            function_responses=[genai.types.FunctionResponse(\n",
        "                name=fc.name,\n",
        "                id=fc.id,\n",
        "                response={'result': 'ok'},\n",
        "            )]\n",
        "        )\n",
        "        await stream.send(input=tool_response)\n",
        "\n",
        "    print('.', end='')\n",
        "\n",
        "  print()\n",
        "\n",
        "  # Play the audio\n",
        "  if turn_buf.tell():\n",
        "    audio = np.frombuffer(turn_buf.getvalue(), dtype=np.int16)\n",
        "    display(Audio(audio, autoplay=True, rate=sample_rate))\n",
        "  else:\n",
        "    print('No audio :(')\n",
        "    print(f'  {len(all_responses)=}')\n",
        "\n",
        "  return all_responses\n",
        "\n",
        "\n",
        "async def run(query, config=None):\n",
        "  # Add any tools or other generation config.\n",
        "  config = BASE_MODEL_CONFIG | (config or {})\n",
        "\n",
        "  # Establish a live session. While this context manager is active, the\n",
        "  # conversation will continue.\n",
        "  async with client.aio.live.connect(model=LIVE_MODEL_ID, config=config) as strm:\n",
        "\n",
        "    # Send the prompt.\n",
        "    await strm.send(input=query, end_of_turn=True)\n",
        "    # Handle the model response.\n",
        "    responses = await play_response(strm)\n",
        "\n",
        "    return responses"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "zMevh_9NodRJ"
      },
      "source": [
        "### Stream with the Search tool\n",
        "\n",
        "First, execute a query _without_ the Search tool to observe the model's response to a time-sensitive query.\n",
        "\n",
        "Note that the Multimodal Live API is a 2-way streaming API, but to simplify running in a notebook, each audio response is buffered and played once it has been fully streamed, so you will need to wait a few seconds before the response starts to play."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "0wXCugI3eOtS"
      },
      "outputs": [],
      "source": [
        "await run('Who won the skateboarding gold medals in the 2024 olympics?');"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "evvh0DgdpSBV"
      },
      "source": [
        "Now re-run with the Search tool enabled."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "HYGEtdjupXM7"
      },
      "outputs": [],
      "source": [
        "responses = await run('Who won the skateboarding gold medals in the 2024 olympics?', {'tools': [search_tool]})"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "r_7R6nAMp9zf"
      },
      "source": [
        "If you wish to see the full output that was returned, you can enable `show_output` here and run this cell. It includes the complete audio binary data, so it is off by default."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "_UUZ5V_Upzpm"
      },
      "outputs": [],
      "source": [
        "show_output = False\n",
        "\n",
        "if show_output:\n",
        "  for msg in responses:\n",
        "    print(msg.model_dump(exclude_none=True))"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "wtt8p612q5CT"
      },
      "source": [
        "### Search with custom tools\n",
        "\n",
        "In the Multimodal Live API, the Search tool can be used in conjunction with other tools, including function calls that you provide to the model.\n",
        "\n",
        "In this example, you define a function `set_climate` that takes 2 parameters, `mode` (`hot`, `cold`, etc) and `strength` (0-10), and ask the model to set the climate control based on the live weather in the location you specify."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "7-nQ1Sp9yM33"
      },
      "outputs": [],
      "source": [
        "set_climate_tool = {'function_declarations': [{\n",
        "    'name': 'set_climate',\n",
        "    'description': 'Switches the local climate control equipment to the specified parameters.',\n",
        "    'parameters': {\n",
        "      'type': 'OBJECT',\n",
        "      'properties': {\n",
        "        # Define the \"mode\" argument.\n",
        "        'mode': {\n",
        "            'type': 'STRING',\n",
        "            'enum': [\n",
        "              # Define the possible values for \"mode\".\n",
        "              \"hot\",\n",
        "              \"cold\",\n",
        "              \"fan\",\n",
        "              \"off\",\n",
        "            ],\n",
        "            'description': 'Mode for the climate unit - whether to heat, cool or just blow air.',\n",
        "        },\n",
        "        # Define the \"strength\" argument.\n",
        "        'strength': {\n",
        "            'type': 'INTEGER',\n",
        "            'description': 'Intensity of the climate to apply, 0-10 (0 is off, 10 is MAX).',\n",
        "        },\n",
        "      },\n",
        "    },\n",
        "  },\n",
        "]}\n",
        "\n",
        "search_tool = {'google_search': {}}\n",
        "\n",
        "tools = {'tools': [search_tool, set_climate_tool]}\n",
        "\n",
        "responses = await run(\"Look up the weather in Paris using search and set my climate control appropriately. I trust your judgement, so just do it.\", tools)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "hvZvdxr7oJ7i"
      },
      "source": [
        "Now inspect the `tool_call` response(s) you received during the conversation."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "ZzZlE9IFnwpS"
      },
      "outputs": [],
      "source": [
        "for r in responses:\n",
        "  if tool := r.tool_call:\n",
        "    for fn in tool.function_calls:\n",
        "      args = ', '.join(f'{k}={v}' for k, v in fn.args.items())\n",
        "      print(f'{fn.name}({args})  # id={fn.id}')"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "dOt32shZaEXj"
      },
      "source": [
        "## Next steps\n",
        "\n",
        "<a name=\"next_steps\"></a>\n",
        "\n",
        "Search grounding is not the only way to ground your requests, you can also use Youtube links and URL context. Check the [Grounding](./Grounding.ipynb) guide for more info on those capabilities.\n",
        "\n",
        "* For more demos showcasing multi-tool use in the Multimodal Live API, check out the [Plotting and Mapping cookbook](../examples/LiveAPI_plotting_and_mapping.ipynb).\n",
        "* To get started with the Live API with the Python SDK, check out the [starter guide](./Get_started_LiveAPI.ipynb).\n",
        "* To learn more about tool use in the Live API, check out the [Live API Tool Use cookbook](./Get_started_LiveAPI_tools.ipynb).\n",
        "\n",
        "Also check the other Gemini advanced capabilities (like [spatial understanding](../quickstarts/Spatial_understanding.ipynb)) that you can find in the [Gemini Cookbook](https://github.com/google-gemini/cookbook/tree/main/gemini-2/)."
      ]
    }
  ],
  "metadata": {
    "colab": {
      "collapsed_sections": [
        "Tce3stUlHN0L"
      ],
      "name": "Search_Grounding.ipynb",
      "toc_visible": true,
      "provenance": [],
      "include_colab_link": true
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}